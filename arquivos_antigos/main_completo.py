import asyncio
import csv
import time
import logging
from datetime import datetime
from playwright.async_api import async_playwright, expect
from dotenv import load_dotenv
import os

# Configura√ß√£o do sistema de logging
def configurar_logging():
    """
    Configura o sistema de logging para arquivo e console
    """
    # Cria pasta de logs se n√£o existir
    os.makedirs("logs", exist_ok=True)
    
    # Nome do arquivo de log com timestamp
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_filename = f"logs/adalove_extraction_{timestamp}.log"
    
    # Configura√ß√£o do logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s | %(levelname)s | %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S',
        handlers=[
            logging.FileHandler(log_filename, encoding='utf-8'),
            logging.StreamHandler()  # Para exibir no console tamb√©m
        ]
    )
    
    logger = logging.getLogger(__name__)
    logger.info(f"üöÄ Iniciando nova sess√£o de extra√ß√£o - Log: {log_filename}")
    return logger

# Carregar vari√°veis do arquivo .env
load_dotenv()

LOGIN = os.environ.get("LOGIN")
SENHA = os.environ.get("SENHA")

logger = configurar_logging()

async def fazer_login_inteligente(page):
    """
    Fun√ß√£o inteligente que detecta o tipo de login necess√°rio
    """
    logger.info("üîë Iniciando processo de login inteligente...")
    
    try:
        # Clica no bot√£o "Entrar com o Google"
        logger.info("üîë Procurando bot√£o 'Entrar com o Google'...")
        botao_google = page.get_by_role("button", name="Entrar com o Google")
        
        if await botao_google.is_visible(timeout=10000):
            logger.info("‚úÖ Bot√£o Google encontrado, clicando...")
            await botao_google.click()
        else:
            logger.error("‚ùå Bot√£o 'Entrar com o Google' n√£o encontrado")
            return False
        
        # Aguarda 4 segundos para ver onde foi parar
        await page.wait_for_timeout(4000)
        
        current_url = page.url
        logger.info(f"üìç URL ap√≥s click no bot√£o Google: {current_url}")
        
        # Analisa onde estamos ap√≥s o click
        if "accounts.google.com" in current_url:
            logger.info("üåê Redirecionado para Google - fazendo login completo...")
            return await fazer_login_google_completo(page)
            
        elif "adalove.inteli.edu.br" in current_url and "/feed" in current_url:
            logger.info("‚úÖ Login autom√°tico bem-sucedido - chegou no feed!")
            return True
            
        elif "adalove.inteli.edu.br" in current_url and "/login" not in current_url:
            logger.info("‚úÖ Login autom√°tico bem-sucedido - j√° estava na plataforma!")
            return True
            
        else:
            logger.info("‚ùì Aguardando conclus√£o do login...")
            # Aguarda mais tempo para ver se vai para o feed
            await page.wait_for_timeout(10000)
            
            current_url = page.url
            logger.info(f"üìç URL ap√≥s espera adicional: {current_url}")
            
            if "adalove.inteli.edu.br" in current_url and ("feed" in current_url or "/login" not in current_url):
                logger.info("‚úÖ Login conclu√≠do com sucesso!")
                return True
            else:
                logger.error("‚ùå Login n√£o foi conclu√≠do - timeout atingido")
                return False
                
    except Exception as e:
        logger.error(f"‚ùå Erro no processo de login inteligente: {str(e)}")
        return False

async def fazer_login_google_completo(page):
    """
    Faz o login completo no Google (email + senha)
    """
    logger.info("üìß Iniciando login completo no Google...")
    
    try:
        # Aguarda e preenche email
        logger.info("üìß Procurando campo de email...")
        seletores_email = ["input[type='email']", "#identifierId", "input[name='identifier']"]
        
        email_preenchido = False
        for seletor in seletores_email:
            try:
                logger.info(f"   üîç Tentando seletor de email: {seletor}")
                campo_email = page.locator(seletor)
                await expect(campo_email).to_be_visible(timeout=10000)
                await campo_email.fill(LOGIN)
                email_preenchido = True
                logger.info(f"‚úÖ Email preenchido com sucesso usando: {seletor}")
                break
            except:
                logger.warning(f"   ‚ùå Seletor falhou: {seletor}")
                continue
                
        if not email_preenchido:
            logger.error("‚ùå N√£o foi poss√≠vel preencher o email com nenhum seletor")
            return False
            
        # Clica Pr√≥xima
        logger.info("‚û°Ô∏è Procurando bot√£o 'Pr√≥xima'...")
        botoes_proxima = ["Pr√≥xima", "Next", "Continue"]
        
        botao_clicado = False
        for texto_botao in botoes_proxima:
            try:
                logger.info(f"   üîç Tentando bot√£o: {texto_botao}")
                botao = page.get_by_role("button", name=texto_botao)
                await botao.click(timeout=5000)
                logger.info(f"‚úÖ Clicou em: {texto_botao}")
                botao_clicado = True
                break
            except:
                logger.warning(f"   ‚ùå Bot√£o n√£o encontrado: {texto_botao}")
                continue
        
        if not botao_clicado:
            logger.error("‚ùå N√£o foi poss√≠vel clicar em nenhum bot√£o 'Pr√≥xima'")
        
        # Aguarda p√°gina de senha
        logger.info("‚è≥ Aguardando p√°gina de senha...")
        await page.wait_for_timeout(5000)
        
        # Preenche senha
        logger.info("üîê Procurando campo de senha...")
        seletores_senha = ["input[type='password']", "input[name='password']"]
        
        senha_preenchida = False
        for seletor in seletores_senha:
            try:
                logger.info(f"   üîç Tentando seletor de senha: {seletor}")
                campo_senha = page.locator(seletor)
                await expect(campo_senha).to_be_visible(timeout=15000)
                await campo_senha.fill(SENHA)
                senha_preenchida = True
                logger.info(f"‚úÖ Senha preenchida com sucesso usando: {seletor}")
                break
            except:
                logger.warning(f"   ‚ùå Seletor falhou: {seletor}")
                continue
                
        if not senha_preenchida:
            logger.error("‚ùå N√£o foi poss√≠vel preencher a senha")
            return False
        
        # Clica bot√£o final
        logger.info("üéØ Finalizando login...")
        botao_clicado = False
        for texto_botao in botoes_proxima:
            try:
                botao = page.get_by_role("button", name=texto_botao)
                await botao.click(timeout=5000)
                logger.info(f"‚úÖ Clicou no bot√£o final: {texto_botao}")
                botao_clicado = True
                break
            except:
                continue
        
        if not botao_clicado:
            logger.warning("‚ö†Ô∏è  N√£o foi poss√≠vel clicar no bot√£o final - tentando continuar")
        
        # Aguarda redirecionamento para AdaLove
        logger.info("‚è≥ Aguardando redirecionamento para AdaLove...")
        for i in range(30):
            await page.wait_for_timeout(1000)
            current_url = page.url
            logger.debug(f"   Verifica√ß√£o {i+1}/30 - URL: {current_url}")
            
            if "adalove.inteli.edu.br" in current_url and ("feed" in current_url or "/login" not in current_url):
                logger.info("‚úÖ Login Google completo e redirecionamento bem-sucedido!")
                return True
                
        logger.error("‚ùå Timeout no redirecionamento para AdaLove")
        return False
        
    except Exception as e:
        logger.error(f"‚ùå Erro no login Google: {str(e)}")
        return False

async def navegar_para_academic_life(page):
    """
    Navega diretamente para a p√°gina academic-life
    """
    logger.info("üè† Navegando para academic-life...")
    
    try:
        current_url = page.url
        logger.info(f"üìç URL atual: {current_url}")
        
        # Navega para academic-life
        target_url = "https://adalove.inteli.edu.br/academic-life"
        logger.info(f"üéØ Navegando para: {target_url}")
        
        await page.goto(target_url)
        await page.wait_for_timeout(3000)
        
        # Verifica se chegou no lugar certo
        current_url = page.url
        logger.info(f"üìç Nova URL: {current_url}")
        
        if "academic-life" in current_url:
            logger.info("‚úÖ Navega√ß√£o para academic-life bem-sucedida!")
            return True
        else:
            logger.warning(f"‚ö†Ô∏è  URL n√£o cont√©m 'academic-life': {current_url}")
            return False
            
    except Exception as e:
        logger.error(f"‚ùå Erro ao navegar para academic-life: {str(e)}")
        return False

async def abrir_seletor_turmas(page):
    """
    Abre o seletor/modal de turmas na p√°gina academic-life
    """
    logger.info("üìã Procurando seletor de turmas/m√≥dulo...")
    
    try:
        # Aguarda a p√°gina carregar completamente
        await page.wait_for_timeout(3000)
        
        # M√∫ltiplos seletores poss√≠veis para o dropdown/seletor de turmas
        seletores_dropdown = [
            ".MuiFormControl-root.MuiFormControl-fullWidth",
            ".css-165oggv",
            ".MuiInputBase-root.MuiOutlinedInput-root", 
            ".css-3joqfb",
            "[role='combobox']",
            "select",
            ".MuiSelect-root",
            ".MuiSelect-select",
            "[data-testid='select-class']",
            "[data-testid='class-selector']"
        ]
        
        dropdown_encontrado = False
        seletor_usado = None
        
        for seletor in seletores_dropdown:
            try:
                logger.info(f"   üîç Tentando seletor: {seletor}")
                dropdown = page.locator(seletor).first
                
                if await dropdown.is_visible(timeout=3000):
                    logger.info(f"   ‚úÖ Dropdown encontrado com: {seletor}")
                    await dropdown.click()
                    dropdown_encontrado = True
                    seletor_usado = seletor
                    break
                    
            except Exception as e:
                logger.debug(f"   ‚ùå Seletor falhou: {seletor} - {str(e)}")
                continue
        
        if not dropdown_encontrado:
            logger.warning("‚ùå Dropdown n√£o encontrado com seletores autom√°ticos")
            logger.info("ü§ö Solicitando interven√ß√£o manual...")
            print("\n" + "="*50)
            print("ü§ö INTERVEN√á√ÉO MANUAL NECESS√ÅRIA")
            print("="*50)
            print("üëÜ Clique manualmente no seletor de turmas/m√≥dulo na p√°gina")
            print("‚è∏Ô∏è  Pressione Enter no terminal ap√≥s clicar")
            print("="*50)
            
            input("Aguardando... Pressione Enter ap√≥s clicar no seletor: ")
            logger.info("‚úÖ Usu√°rio confirmou interven√ß√£o manual no seletor")
        else:
            logger.info(f"‚úÖ Seletor clicado automaticamente com: {seletor_usado}")
        
        # Aguarda modal/dropdown abrir
        await page.wait_for_timeout(2000)
        logger.info("‚è≥ Aguardando modal de turmas abrir...")
        
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Erro ao abrir seletor de turmas: {str(e)}")
        return False

async def filtrar_e_selecionar_turma(page):
    """
    Pede input do usu√°rio e filtra/seleciona a turma desejada
    """
    logger.info("üéØ Iniciando processo de sele√ß√£o de turma...")
    
    try:
        # Solicita input do usu√°rio
        print("\n" + "="*60)
        print("üìã SELE√á√ÉO DE TURMA")
        print("="*60)
        print("Agora voc√™ precisa informar o nome EXATO da turma que deseja acessar.")
        print("Este nome ser√° usado para filtrar a lista de turmas dispon√≠veis.")
        print("Exemplos: '2025-1B-T13', 'GRAD ES06', 'Turma 13', etc.")
        print("="*60)
        
        nome_turma = input("Digite o nome exato da turma: ").strip()
        
        if not nome_turma:
            logger.error("‚ùå Nome da turma n√£o informado")
            return False
            
        logger.info(f"üéØ Turma informada pelo usu√°rio: '{nome_turma}'")
        
        # Procura pelo campo de input/filtro no modal
        logger.info("üîç Procurando campo de filtro no modal...")
        
        seletores_input = [
            "input[type='text']",
            "input[placeholder*='turma']",
            "input[placeholder*='filtro']", 
            "input[placeholder*='pesquisar']",
            "input[placeholder*='buscar']",
            ".MuiInputBase-input",
            "[data-testid='search-input']",
            "[data-testid='filter-input']"
        ]
        
        campo_encontrado = False
        
        for seletor in seletores_input:
            try:
                logger.info(f"   üîç Tentando seletor de input: {seletor}")
                campo_input = page.locator(seletor).first
                
                if await campo_input.is_visible(timeout=3000):
                    logger.info(f"   ‚úÖ Campo de filtro encontrado: {seletor}")
                    
                    # Limpa o campo e digita o nome da turma
                    await campo_input.clear()
                    await campo_input.fill(nome_turma)
                    
                    logger.info(f"‚úÖ Nome da turma digitado no filtro: '{nome_turma}'")
                    campo_encontrado = True
                    break
                    
            except Exception as e:
                logger.debug(f"   ‚ùå Seletor falhou: {seletor} - {str(e)}")
                continue
        
        if not campo_encontrado:
            logger.warning("‚ùå Campo de filtro n√£o encontrado automaticamente")
            logger.info("ü§ö Solicitando interven√ß√£o manual...")
            print("\n" + "="*50)
            print("ü§ö INTERVEN√á√ÉO MANUAL NECESS√ÅRIA")
            print("="*50)
            print(f"üëÜ Digite manualmente '{nome_turma}' no campo de filtro do modal")
            print("‚è∏Ô∏è  Pressione Enter no terminal ap√≥s digitar")
            print("="*50)
            
            input("Aguardando... Pressione Enter ap√≥s digitar o nome: ")
            logger.info("‚úÖ Usu√°rio confirmou digita√ß√£o manual do nome")
        
        # Aguarda filtro ser aplicado
        await page.wait_for_timeout(2000)
        logger.info("‚è≥ Aguardando filtro ser aplicado...")
        
        # Procura e clica na op√ß√£o filtrada
        logger.info("üéØ Procurando op√ß√£o da turma na lista filtrada...")
        
        seletores_opcoes = [
            f"text={nome_turma}",
            f"*[text*='{nome_turma}']",
            ".MuiMenuItem-root",
            "[role='option']",
            ".MuiList-root li",
            ".dropdown-item",
            "[data-testid='class-option']"
        ]
        
        opcao_clicada = False
        
        # Primeiro tenta encontrar por texto exato
        try:
            logger.info(f"   üîç Procurando por texto exato: '{nome_turma}'")
            opcao_exata = page.get_by_text(nome_turma, exact=True).first
            
            if await opcao_exata.is_visible(timeout=5000):
                await opcao_exata.click()
                logger.info(f"‚úÖ Clicou na turma por texto exato: '{nome_turma}'")
                opcao_clicada = True
            
        except Exception as e:
            logger.debug(f"   ‚ùå Busca por texto exato falhou: {str(e)}")
        
        # Se n√£o encontrou por texto exato, tenta busca parcial
        if not opcao_clicada:
            try:
                logger.info(f"   üîç Procurando por texto parcial: '{nome_turma}'")
                opcao_parcial = page.get_by_text(nome_turma, exact=False).first
                
                if await opcao_parcial.is_visible(timeout=5000):
                    await opcao_parcial.click()
                    logger.info(f"‚úÖ Clicou na turma por texto parcial: '{nome_turma}'")
                    opcao_clicada = True
                
            except Exception as e:
                logger.debug(f"   ‚ùå Busca por texto parcial falhou: {str(e)}")
        
        # Se ainda n√£o encontrou, tenta pelos seletores gen√©ricos
        if not opcao_clicada:
            logger.info("   üîç Tentando seletores gen√©ricos de op√ß√µes...")
            
            for seletor in seletores_opcoes[2:]:  # Pula os seletores de texto
                try:
                    logger.info(f"   üîç Tentando seletor: {seletor}")
                    opcoes = page.locator(seletor)
                    count = await opcoes.count()
                    
                    if count > 0:
                        # Procura pela op√ß√£o que cont√©m o nome da turma
                        for i in range(count):
                            try:
                                opcao = opcoes.nth(i)
                                texto = await opcao.text_content()
                                
                                if texto and nome_turma.lower() in texto.lower():
                                    await opcao.click()
                                    logger.info(f"‚úÖ Clicou na op√ß√£o: '{texto.strip()}'")
                                    opcao_clicada = True
                                    break
                                    
                            except:
                                continue
                        
                        if opcao_clicada:
                            break
                            
                except Exception as e:
                    logger.debug(f"   ‚ùå Seletor falhou: {seletor} - {str(e)}")
                    continue
        
        if not opcao_clicada:
            logger.warning("‚ùå Op√ß√£o da turma n√£o encontrada automaticamente")
            logger.info("ü§ö Solicitando interven√ß√£o manual...")
            print("\n" + "="*50)
            print("ü§ö INTERVEN√á√ÉO MANUAL NECESS√ÅRIA") 
            print("="*50)
            print(f"üëÜ Clique manualmente na op√ß√£o da turma '{nome_turma}' na lista")
            print("‚è∏Ô∏è  Pressione Enter no terminal ap√≥s clicar")
            print("="*50)
            
            input("Aguardando... Pressione Enter ap√≥s clicar na turma: ")
            logger.info("‚úÖ Usu√°rio confirmou sele√ß√£o manual da turma")
        
        # Aguarda modal fechar e p√°gina carregar
        await page.wait_for_timeout(3000)
        logger.info("‚è≥ Aguardando modal fechar e p√°gina carregar...")
        
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Erro no processo de sele√ß√£o de turma: {str(e)}")
        return False

async def verificar_pagina_turma(page):
    """
    Verifica se chegou na p√°gina da turma corretamente
    """
    logger.info("üîç Verificando se chegou na p√°gina da turma...")
    
    try:
        current_url = page.url
        logger.info(f"üìç URL atual: {current_url}")
        
        # Aguarda p√°gina carregar
        await page.wait_for_timeout(3000)
        
        # Procura por elementos caracter√≠sticos da p√°gina da turma
        elementos_caracteristicos = [
            "text=Semana",
            "[data-rbd-draggable-id]",  # Cards arrast√°veis
            ".week-container",
            ".academic-week",
            "text=Cards"
        ]
        
        elementos_encontrados = 0
        
        for elemento in elementos_caracteristicos:
            try:
                if await page.locator(elemento).count() > 0:
                    elementos_encontrados += 1
                    logger.info(f"   ‚úÖ Elemento encontrado: {elemento}")
                else:
                    logger.info(f"   ‚ùå Elemento n√£o encontrado: {elemento}")
            except:
                logger.info(f"   ‚ùå Erro ao procurar elemento: {elemento}")
        
        logger.info(f"üìä Elementos caracter√≠sticos encontrados: {elementos_encontrados}/{len(elementos_caracteristicos)}")
        
        if elementos_encontrados >= 2:
            logger.info("‚úÖ P√°gina da turma carregada com sucesso!")
            return True
        else:
            logger.warning("‚ö†Ô∏è  P√°gina da turma pode n√£o ter carregado completamente")
            return False
            
    except Exception as e:
        logger.error(f"‚ùå Erro ao verificar p√°gina da turma: {str(e)}")
        return False

async def fechar_popup_faltas(page):
    """
    Fecha o popup de faltas se aparecer
    """
    logger.info("üö´ Verificando se h√° popup de faltas...")
    
    try:
        await page.wait_for_timeout(3000)  # Aguarda popup aparecer se houver
        
        # Procura pelo bot√£o "Fechar"
        seletores_fechar = [
            "button:has-text('Fechar')",
            "[aria-label='Fechar']",
            ".MuiButton-root:has-text('Fechar')",
            "[role='button']:has-text('Fechar')",
            ".close-button",
            ".popup-close",
            "[data-testid='close-modal']"
        ]
        
        popup_fechado = False
        
        for seletor in seletores_fechar:
            try:
                logger.info(f"   üîç Procurando bot√£o fechar: {seletor}")
                botao_fechar = page.locator(seletor)
                
                if await botao_fechar.is_visible(timeout=3000):
                    await botao_fechar.click()
                    logger.info(f"‚úÖ Popup fechado com bot√£o: {seletor}")
                    popup_fechado = True
                    break
                    
            except Exception as e:
                logger.debug(f"   ‚ùå Seletor falhou: {seletor} - {str(e)}")
                continue
        
        if not popup_fechado:
            logger.info("‚ÑπÔ∏è  Nenhum popup de faltas detectado")
        
        await page.wait_for_timeout(2000)  # Aguarda popup fechar completamente
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Erro ao fechar popup de faltas: {str(e)}")
        return False

async def testar_acesso_semanas(context):
    """
    Testa acesso √†s primeiras 3 semanas para verificar se tudo est√° funcionando
    """
    logger.info("üß™ Testando acesso √†s semanas para valida√ß√£o...")
    
    semanas = ["Semana 01", "Semana 02", "Semana 03"]
    resultados = []
    
    for semana in semanas:
        page = await context.new_page()
        
        try:
            logger.info(f"   üîç Testando: {semana}")
            
            await page.goto("https://adalove.inteli.edu.br/academic-life")
            await page.wait_for_timeout(3000)
            
            # Fecha popup de faltas se aparecer nesta p√°gina tamb√©m
            await fechar_popup_faltas(page)
            
            # Procura pela semana
            elemento = page.get_by_text(semana, exact=False)
            if await elemento.count() > 0:
                await elemento.first.click(timeout=8000)
                await page.wait_for_timeout(3000)
                
                # Conta cards
                cards = await page.query_selector_all('[data-rbd-draggable-id]')
                logger.info(f"   ‚úÖ {semana}: {len(cards)} cards encontrados")
                resultados.append({"semana": semana, "cards": len(cards), "sucesso": True})
            else:
                logger.warning(f"   ‚ùå {semana}: n√£o encontrada")
                resultados.append({"semana": semana, "cards": 0, "sucesso": False})
                
        except Exception as e:
            logger.error(f"   ‚ùå {semana}: erro - {str(e)}")
            resultados.append({"semana": semana, "cards": 0, "sucesso": False})
            
        finally:
            await page.close()
    
    # Resumo dos resultados
    sucessos = sum(1 for r in resultados if r["sucesso"])
    total_cards = sum(r["cards"] for r in resultados)
    
    logger.info(f"üìä Resultado do teste: {sucessos}/3 semanas acessadas, {total_cards} cards total")
    
    if sucessos > 0:
        logger.info("‚úÖ Teste de valida√ß√£o passou - automa√ß√£o funcionando!")
    else:
        logger.error("‚ùå Teste de valida√ß√£o falhou - verificar configura√ß√£o")
    
    return sucessos > 0

async def main():
    """
    Fun√ß√£o principal com fluxo reformulado
    """
    logger.info("üöÄ Iniciando extra√ß√£o reformulada do AdaLove...")
    logger.info(f"üë§ Usu√°rio: {LOGIN}")
    start_time = time.time()

    async with async_playwright() as p:
        try:
            logger.info("üåê Iniciando navegador...")
            browser = await p.chromium.launch(channel="chrome", headless=False)
            context = await browser.new_context()
            page = await context.new_page()
            
            # 1. Acessa AdaLove
            logger.info("üåê Acessando p√°gina inicial do AdaLove...")
            await page.goto("https://adalove.inteli.edu.br/")
            await page.wait_for_timeout(3000)
            
            # 2. Faz login inteligente  
            logger.info("üîê Iniciando processo de login...")
            login_sucesso = await fazer_login_inteligente(page)
            
            if not login_sucesso:
                logger.error("‚ùå Falha no login autom√°tico")
                logger.info("ü§ö PAUSANDO para interven√ß√£o manual no login...")
                
                print("\n" + "="*50)
                print("ü§ö INTERVEN√á√ÉO MANUAL NECESS√ÅRIA - LOGIN")
                print("="*50)
                print("‚ùå O login autom√°tico falhou.")
                print("üëÜ Complete o login manualmente na p√°gina")
                print("‚è∏Ô∏è  Pressione Enter ap√≥s fazer login com sucesso")
                print("="*50)
                
                input("Aguardando... Pressione Enter ap√≥s login manual: ")
                logger.info("‚úÖ Usu√°rio confirmou login manual")
            
            # 3. Navega diretamente para academic-life
            logger.info("üè† Navegando para academic-life...")
            navegacao_sucesso = await navegar_para_academic_life(page)
            
            if not navegacao_sucesso:
                logger.error("‚ùå Falha na navega√ß√£o para academic-life")
                return
            
            # 4. Fecha popup de faltas se aparecer
            await fechar_popup_faltas(page)
            
            # 5. Abre seletor de turmas
            logger.info("üìã Abrindo seletor de turmas...")
            seletor_sucesso = await abrir_seletor_turmas(page)
            
            if not seletor_sucesso:
                logger.error("‚ùå Falha ao abrir seletor de turmas")
                return
            
            # 6. Filtra e seleciona turma
            logger.info("üéØ Filtrando e selecionando turma...")
            selecao_sucesso = await filtrar_e_selecionar_turma(page)
            
            if not selecao_sucesso:
                logger.error("‚ùå Falha na sele√ß√£o da turma")
                return
            
            # 7. Verifica se chegou na p√°gina da turma
            logger.info("üîç Verificando p√°gina da turma...")
            pagina_sucesso = await verificar_pagina_turma(page)
            
            if not pagina_sucesso:
                logger.warning("‚ö†Ô∏è  P√°gina da turma pode n√£o ter carregado corretamente")
            
            # 8. Fecha popup de faltas novamente (pode aparecer na nova p√°gina)
            await fechar_popup_faltas(page)
            
            # 9. Testa acesso √†s semanas
            logger.info("üß™ Executando teste de valida√ß√£o...")
            teste_sucesso = await testar_acesso_semanas(context)
            
            if teste_sucesso:
                logger.info("üéâ SUCESSO! Configura√ß√£o da turma conclu√≠da!")
                logger.info("‚úÖ Pronto para extra√ß√£o completa de todas as semanas")
                
                print("\n" + "="*60)
                print("üéâ CONFIGURA√á√ÉO CONCLU√çDA COM SUCESSO!")
                print("="*60)
                print("‚úÖ Login realizado")
                print("‚úÖ Navega√ß√£o para academic-life")
                print("‚úÖ Sele√ß√£o de turma")
                print("‚úÖ Teste de acesso √†s semanas")
                print("="*60)
                print("‚è∏Ô∏è  Pressione Enter para continuar com a extra√ß√£o completa...")
                print("‚ùå Ou feche o navegador para sair")
                print("="*60)
                
                input("Aguardando... Pressione Enter para prosseguir: ")
                logger.info("‚úÖ Usu√°rio confirmou prosseguimento")
                
            else:
                logger.error("‚ùå Teste de valida√ß√£o falhou - verificar configura√ß√£o")
                
                print("\n" + "="*60)
                print("‚ùå TESTE DE VALIDA√á√ÉO FALHOU")
                print("="*60)
                print("‚ö†Ô∏è  A configura√ß√£o n√£o passou no teste de valida√ß√£o")
                print("üîß Verifique se a turma foi selecionada corretamente")
                print("‚è∏Ô∏è  Pressione Enter para sair")
                print("="*60)
                
                input("Pressione Enter para sair: ")
                logger.info("‚ùå Usu√°rio confirmou sa√≠da ap√≥s falha no teste")
        
        except Exception as e:
            logger.error(f"‚ùå Erro geral na execu√ß√£o: {str(e)}")
            
            print("\n" + "="*60)
            print("‚ùå ERRO GERAL")
            print("="*60)
            print(f"Erro: {str(e)}")
            print("‚è∏Ô∏è  Pressione Enter para sair")
            print("="*60)
            
            input("Pressione Enter para sair: ")
            
        finally:
            logger.info("üîö Finalizando navegador...")
            if 'context' in locals():
                await context.close()
            if 'browser' in locals():
                await browser.close()

    end_time = time.time()
    duration = end_time - start_time
    logger.info(f"‚è±Ô∏è  Execu√ß√£o conclu√≠da em {duration:.1f}s")

if __name__ == "__main__":
    asyncio.run(main())
