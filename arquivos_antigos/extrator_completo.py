import asyncio
import csv
import time
import logging
from datetime import datetime
from playwright.async_api import async_playwright, expect
from dotenv import load_dotenv
import os
import json

# Configura√ß√£o do sistema de logging
def configurar_logging():
    """
    Configura o sistema de logging para arquivo e console
    """
    os.makedirs("logs", exist_ok=True)
    os.makedirs("dados_extraidos", exist_ok=True)
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_filename = f"logs/extracao_completa_{timestamp}.log"
    
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s | %(levelname)s | %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S',
        handlers=[
            logging.FileHandler(log_filename, encoding='utf-8'),
            logging.StreamHandler()
        ]
    )
    
    logger = logging.getLogger(__name__)
    logger.info(f"üöÄ Iniciando extra√ß√£o completa - Log: {log_filename}")
    return logger

# Carregar vari√°veis do arquivo .env
load_dotenv()

LOGIN = os.environ.get("LOGIN")
SENHA = os.environ.get("SENHA")

logger = configurar_logging()

async def fazer_login_inteligente(page):
    """
    Fun√ß√£o de login inteligente (mesma do script anterior)
    """
    logger.info("üîë Iniciando processo de login inteligente...")
    
    try:
        logger.info("üîë Procurando bot√£o 'Entrar com o Google'...")
        botao_google = page.get_by_role("button", name="Entrar com o Google")
        
        if await botao_google.is_visible(timeout=10000):
            logger.info("‚úÖ Bot√£o Google encontrado, clicando...")
            await botao_google.click()
        else:
            logger.error("‚ùå Bot√£o 'Entrar com o Google' n√£o encontrado")
            return False
        
        await page.wait_for_timeout(4000)
        current_url = page.url
        logger.info(f"üìç URL ap√≥s click no bot√£o Google: {current_url}")
        
        if "accounts.google.com" in current_url:
            logger.info("üåê Redirecionado para Google - fazendo login completo...")
            return await fazer_login_google_completo(page)
            
        elif "adalove.inteli.edu.br" in current_url and "/feed" in current_url:
            logger.info("‚úÖ Login autom√°tico bem-sucedido - chegou no feed!")
            return True
            
        elif "adalove.inteli.edu.br" in current_url and "/login" not in current_url:
            logger.info("‚úÖ Login autom√°tico bem-sucedido - j√° estava na plataforma!")
            return True
            
        else:
            logger.info("‚ùì Aguardando conclus√£o do login...")
            await page.wait_for_timeout(10000)
            
            current_url = page.url
            logger.info(f"üìç URL ap√≥s espera adicional: {current_url}")
            
            if "adalove.inteli.edu.br" in current_url and ("feed" in current_url or "/login" not in current_url):
                logger.info("‚úÖ Login conclu√≠do com sucesso!")
                return True
            else:
                logger.error("‚ùå Login n√£o foi conclu√≠do - timeout atingido")
                return False
                
    except Exception as e:
        logger.error(f"‚ùå Erro no processo de login: {str(e)}")
        return False

async def fazer_login_google_completo(page):
    """
    Faz o login completo no Google (email + senha)
    """
    logger.info("üìß Iniciando login completo no Google...")
    
    try:
        # Email
        logger.info("üìß Procurando campo de email...")
        seletores_email = ["input[type='email']", "#identifierId", "input[name='identifier']"]
        
        email_preenchido = False
        for seletor in seletores_email:
            try:
                campo_email = page.locator(seletor)
                await expect(campo_email).to_be_visible(timeout=10000)
                await campo_email.fill(LOGIN)
                email_preenchido = True
                logger.info(f"‚úÖ Email preenchido com: {seletor}")
                break
            except:
                continue
                
        if not email_preenchido:
            logger.error("‚ùå N√£o foi poss√≠vel preencher o email")
            return False
        
        # Pr√≥xima
        logger.info("‚û°Ô∏è Procurando bot√£o 'Pr√≥xima'...")
        botoes_proxima = ["Pr√≥xima", "Next", "Continue"]
        
        for texto_botao in botoes_proxima:
            try:
                botao = page.get_by_role("button", name=texto_botao)
                await botao.click(timeout=5000)
                logger.info(f"‚úÖ Clicou em: {texto_botao}")
                break
            except:
                continue
        
        await page.wait_for_timeout(5000)
        
        # Senha
        logger.info("üîê Procurando campo de senha...")
        seletores_senha = ["input[type='password']", "input[name='password']"]
        
        senha_preenchida = False
        for seletor in seletores_senha:
            try:
                campo_senha = page.locator(seletor)
                await expect(campo_senha).to_be_visible(timeout=15000)
                await campo_senha.fill(SENHA)
                senha_preenchida = True
                logger.info(f"‚úÖ Senha preenchida com: {seletor}")
                break
            except:
                continue
                
        if not senha_preenchida:
            logger.error("‚ùå N√£o foi poss√≠vel preencher a senha")
            return False
        
        # Bot√£o final
        logger.info("üéØ Finalizando login...")
        for texto_botao in botoes_proxima:
            try:
                botao = page.get_by_role("button", name=texto_botao)
                await botao.click(timeout=5000)
                logger.info(f"‚úÖ Clicou no bot√£o final: {texto_botao}")
                break
            except:
                continue
        
        # Aguarda redirecionamento
        logger.info("‚è≥ Aguardando redirecionamento para AdaLove...")
        for i in range(30):
            await page.wait_for_timeout(1000)
            current_url = page.url
            
            if "adalove.inteli.edu.br" in current_url and ("feed" in current_url or "/login" not in current_url):
                logger.info("‚úÖ Login Google completo!")
                return True
                
        logger.error("‚ùå Timeout no redirecionamento")
        return False
        
    except Exception as e:
        logger.error(f"‚ùå Erro no login Google: {str(e)}")
        return False

async def navegar_para_academic_life(page):
    """
    Navega para academic-life
    """
    logger.info("üè† Navegando para academic-life...")
    
    try:
        current_url = page.url
        logger.info(f"üìç URL atual: {current_url}")
        
        target_url = "https://adalove.inteli.edu.br/academic-life"
        logger.info(f"üéØ Navegando para: {target_url}")
        
        await page.goto(target_url)
        await page.wait_for_timeout(3000)
        
        current_url = page.url
        logger.info(f"üìç Nova URL: {current_url}")
        
        if "academic-life" in current_url:
            logger.info("‚úÖ Navega√ß√£o para academic-life bem-sucedida!")
            return True
        else:
            logger.warning(f"‚ö†Ô∏è URL n√£o cont√©m 'academic-life': {current_url}")
            return False
            
    except Exception as e:
        logger.error(f"‚ùå Erro ao navegar: {str(e)}")
        return False

async def fechar_popup_faltas(page):
    """
    Fecha popup de faltas se aparecer
    """
    logger.info("üö´ Verificando popup de faltas...")
    
    try:
        await page.wait_for_timeout(3000)
        
        seletores_fechar = [
            "button:has-text('Fechar')",
            "[aria-label='Fechar']", 
            ".MuiButton-root:has-text('Fechar')",
            "[role='button']:has-text('Fechar')",
            ".close-button",
            ".popup-close"
        ]
        
        for seletor in seletores_fechar:
            try:
                botao_fechar = page.locator(seletor)
                if await botao_fechar.is_visible(timeout=3000):
                    await botao_fechar.click()
                    logger.info(f"‚úÖ Popup fechado com: {seletor}")
                    await page.wait_for_timeout(2000)
                    return True
            except:
                continue
        
        logger.info("‚ÑπÔ∏è Nenhum popup detectado")
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Erro ao fechar popup: {str(e)}")
        return False

async def selecionar_turma_manual(page):
    """
    Permite sele√ß√£o manual da turma (mais confi√°vel)
    """
    logger.info("üéØ Iniciando sele√ß√£o de turma...")
    
    print("\n" + "="*60)
    print("üìã SELE√á√ÉO DE TURMA - PROCESSO MANUAL")
    print("="*60)
    print("ü§ö Para garantir precis√£o, vamos fazer a sele√ß√£o manualmente:")
    print("1. Clique no seletor de turmas na p√°gina")
    print("2. Digite ou selecione a turma desejada")
    print("3. Clique na op√ß√£o da turma")
    print("4. Aguarde a p√°gina carregar")
    print("5. Pressione Enter aqui no terminal quando conclu√≠do")
    print("="*60)
    
    input("‚è∏Ô∏è Pressione Enter ap√≥s selecionar a turma na interface: ")
    
    logger.info("‚úÖ Usu√°rio confirmou sele√ß√£o da turma")
    await page.wait_for_timeout(3000)
    
    return True

async def descobrir_semanas_disponiveis(page):
    """
    Descobre automaticamente todas as semanas dispon√≠veis
    """
    logger.info("üîç Descobrindo semanas dispon√≠veis...")
    
    try:
        # Aguarda p√°gina carregar
        await page.wait_for_timeout(3000)
        
        # Procura por elementos que contenham "Semana"
        seletores_semanas = [
            "text=/Semana \\d+/",
            "text=/Week \\d+/", 
            "[class*='week']",
            "[data-week]",
            ".semana",
            ".week"
        ]
        
        semanas_encontradas = []
        
        # Tenta diferentes seletores
        for seletor in seletores_semanas:
            try:
                elementos = page.locator(seletor)
                count = await elementos.count()
                
                if count > 0:
                    logger.info(f"   üîç Encontradas {count} semanas com seletor: {seletor}")
                    
                    for i in range(count):
                        try:
                            elemento = elementos.nth(i)
                            texto = await elemento.text_content()
                            
                            if texto and "semana" in texto.lower():
                                semanas_encontradas.append(texto.strip())
                                
                        except:
                            continue
                    
                    break
                    
            except Exception as e:
                logger.debug(f"   ‚ùå Seletor falhou: {seletor} - {str(e)}")
                continue
        
        # Remove duplicatas e ordena
        semanas_unicas = list(set(semanas_encontradas))
        semanas_unicas.sort()
        
        logger.info(f"üìä Semanas descobertas: {len(semanas_unicas)}")
        for semana in semanas_unicas:
            logger.info(f"   üìÖ {semana}")
        
        if not semanas_unicas:
            # Fallback: tenta semanas padr√£o
            logger.warning("‚ö†Ô∏è Nenhuma semana encontrada automaticamente, usando padr√£o")
            semanas_unicas = [f"Semana {i:02d}" for i in range(1, 11)]
            logger.info("üìÖ Usando semanas padr√£o: Semana 01 a 10")
        
        return semanas_unicas
        
    except Exception as e:
        logger.error(f"‚ùå Erro ao descobrir semanas: {str(e)}")
        # Retorna semanas padr√£o
        return [f"Semana {i:02d}" for i in range(1, 11)]

async def extrair_cards_semana(page, nome_semana):
    """
    Extrai todos os cards de uma semana espec√≠fica
    """
    logger.info(f"üìã Extraindo cards de: {nome_semana}")
    
    try:
        # Procura e clica na semana
        logger.info(f"   üîç Procurando elemento da semana: {nome_semana}")
        
        elemento_semana = page.get_by_text(nome_semana, exact=False).first
        
        if await elemento_semana.is_visible(timeout=10000):
            await elemento_semana.click()
            logger.info(f"   ‚úÖ Clicou na semana: {nome_semana}")
            await page.wait_for_timeout(3000)
        else:
            logger.warning(f"   ‚ùå Semana n√£o encontrada: {nome_semana}")
            return []
        
        # Procura todos os cards
        logger.info("   üîç Procurando cards...")
        
        seletores_cards = [
            "[data-rbd-draggable-id]",
            ".card",
            ".activity-card", 
            "[class*='card']",
            ".draggable-card"
        ]
        
        cards_encontrados = []
        
        for seletor in seletores_cards:
            try:
                cards = page.locator(seletor)
                count = await cards.count()
                
                if count > 0:
                    logger.info(f"   ‚úÖ {count} cards encontrados com: {seletor}")
                    
                    # Extrai informa√ß√µes de cada card
                    for i in range(count):
                        try:
                            card = cards.nth(i)
                            card_info = await extrair_dados_card(card, i, nome_semana)
                            
                            if card_info:
                                cards_encontrados.append(card_info)
                                
                        except Exception as e:
                            logger.warning(f"   ‚ö†Ô∏è Erro ao extrair card {i}: {str(e)}")
                            continue
                    
                    break
                    
            except Exception as e:
                logger.debug(f"   ‚ùå Seletor falhou: {seletor} - {str(e)}")
                continue
        
        logger.info(f"   üìä Total extra√≠do: {len(cards_encontrados)} cards")
        return cards_encontrados
        
    except Exception as e:
        logger.error(f"‚ùå Erro ao extrair cards da {nome_semana}: {str(e)}")
        return []

async def extrair_dados_card(card, indice, semana):
    """
    Extrai dados detalhados de um card individual
    """
    try:
        card_data = {
            "semana": semana,
            "indice": indice + 1,
            "id": "",
            "titulo": "",
            "descricao": "",
            "tipo": "",
            "status": "",
            "data_entrega": "",
            "tags": "",
            "link": "",
            "texto_completo": ""
        }
        
        # ID do card (se dispon√≠vel)
        try:
            id_element = await card.get_attribute("data-rbd-draggable-id")
            if id_element:
                card_data["id"] = id_element
        except:
            pass
        
        # T√≠tulo (procura em diferentes elementos)
        seletores_titulo = [
            "h1", "h2", "h3", "h4", "h5", "h6",
            ".title", ".card-title", ".activity-title",
            "[class*='title']", ".name", ".card-name"
        ]
        
        for seletor in seletores_titulo:
            try:
                titulo_elem = card.locator(seletor).first
                if await titulo_elem.count() > 0:
                    titulo = await titulo_elem.text_content()
                    if titulo and titulo.strip():
                        card_data["titulo"] = titulo.strip()
                        break
            except:
                continue
        
        # Descri√ß√£o
        seletores_descricao = [
            ".description", ".card-description", ".activity-description",
            "[class*='description']", ".content", ".card-content", 
            ".text", ".card-text", "p"
        ]
        
        for seletor in seletores_descricao:
            try:
                desc_elem = card.locator(seletor).first
                if await desc_elem.count() > 0:
                    descricao = await desc_elem.text_content()
                    if descricao and descricao.strip():
                        card_data["descricao"] = descricao.strip()
                        break
            except:
                continue
        
        # Tipo/Categoria
        seletores_tipo = [
            ".type", ".card-type", ".category", ".tag",
            "[class*='type']", "[class*='category']",
            ".badge", ".label"
        ]
        
        for seletor in seletores_tipo:
            try:
                tipo_elem = card.locator(seletor).first
                if await tipo_elem.count() > 0:
                    tipo = await tipo_elem.text_content()
                    if tipo and tipo.strip():
                        card_data["tipo"] = tipo.strip()
                        break
            except:
                continue
        
        # Data de entrega
        seletores_data = [
            ".date", ".due-date", ".deadline", ".card-date",
            "[class*='date']", "[class*='due']", 
            "time", ".timestamp"
        ]
        
        for seletor in seletores_data:
            try:
                data_elem = card.locator(seletor).first
                if await data_elem.count() > 0:
                    data = await data_elem.text_content()
                    if data and data.strip():
                        card_data["data_entrega"] = data.strip()
                        break
            except:
                continue
        
        # Link (se houver)
        try:
            link_elem = card.locator("a").first
            if await link_elem.count() > 0:
                link = await link_elem.get_attribute("href")
                if link:
                    card_data["link"] = link
        except:
            pass
        
        # Texto completo do card como fallback
        try:
            texto_completo = await card.text_content()
            if texto_completo:
                card_data["texto_completo"] = texto_completo.strip()
        except:
            pass
        
        # Se n√£o conseguiu t√≠tulo, usa parte do texto completo
        if not card_data["titulo"] and card_data["texto_completo"]:
            linhas = card_data["texto_completo"].split('\n')
            primeira_linha = next((linha.strip() for linha in linhas if linha.strip()), "")
            if primeira_linha:
                card_data["titulo"] = primeira_linha[:100]  # Limita a 100 caracteres
        
        return card_data
        
    except Exception as e:
        logger.warning(f"   ‚ö†Ô∏è Erro ao extrair dados do card {indice}: {str(e)}")
        return None

async def salvar_dados_csv(dados, timestamp):
    """
    Salva os dados extra√≠dos em CSV
    """
    logger.info("üíæ Salvando dados em CSV...")
    
    try:
        filename = f"dados_extraidos/cards_adalove_{timestamp}.csv"
        
        if not dados:
            logger.warning("‚ö†Ô∏è Nenhum dado para salvar")
            return
        
        # Headers do CSV
        headers = [
            "semana", "indice", "id", "titulo", "descricao", 
            "tipo", "status", "data_entrega", "tags", "link", "texto_completo"
        ]
        
        with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=headers)
            writer.writeheader()
            
            for linha in dados:
                writer.writerow(linha)
        
        logger.info(f"‚úÖ Dados salvos em: {filename}")
        logger.info(f"üìä Total de cards salvos: {len(dados)}")
        
        return filename
        
    except Exception as e:
        logger.error(f"‚ùå Erro ao salvar CSV: {str(e)}")
        return None

async def salvar_dados_json(dados, timestamp):
    """
    Salva os dados extra√≠dos em JSON (backup)
    """
    logger.info("üíæ Salvando dados em JSON...")
    
    try:
        filename = f"dados_extraidos/cards_adalove_{timestamp}.json"
        
        with open(filename, 'w', encoding='utf-8') as jsonfile:
            json.dump(dados, jsonfile, ensure_ascii=False, indent=2)
        
        logger.info(f"‚úÖ Backup JSON salvo em: {filename}")
        return filename
        
    except Exception as e:
        logger.error(f"‚ùå Erro ao salvar JSON: {str(e)}")
        return None

async def gerar_relatorio_extracao(dados, timestamp):
    """
    Gera relat√≥rio resumido da extra√ß√£o
    """
    logger.info("üìä Gerando relat√≥rio da extra√ß√£o...")
    
    try:
        filename = f"dados_extraidos/relatorio_extracao_{timestamp}.txt"
        
        # An√°lise dos dados
        total_cards = len(dados)
        semanas_processadas = set(card["semana"] for card in dados)
        cards_por_semana = {}
        
        for semana in semanas_processadas:
            cards_por_semana[semana] = sum(1 for card in dados if card["semana"] == semana)
        
        # Gera relat√≥rio
        relatorio = []
        relatorio.append("üìã RELAT√ìRIO DE EXTRA√á√ÉO - ADALOVE CARDS")
        relatorio.append("=" * 60)
        relatorio.append(f"üìÖ Data/Hora: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        relatorio.append(f"üë§ Usu√°rio: {LOGIN}")
        relatorio.append("")
        relatorio.append("üìä RESUMO GERAL")
        relatorio.append("-" * 30)
        relatorio.append(f"üéØ Total de cards extra√≠dos: {total_cards}")
        relatorio.append(f"üìö Semanas processadas: {len(semanas_processadas)}")
        relatorio.append("")
        relatorio.append("üìà CARDS POR SEMANA")
        relatorio.append("-" * 30)
        
        for semana in sorted(semanas_processadas):
            count = cards_por_semana[semana]
            relatorio.append(f"   {semana}: {count} cards")
        
        relatorio.append("")
        relatorio.append("üîç TIPOS DE DADOS EXTRA√çDOS")
        relatorio.append("-" * 30)
        relatorio.append("‚úÖ Semana")
        relatorio.append("‚úÖ √çndice do card")
        relatorio.append("‚úÖ ID (quando dispon√≠vel)")
        relatorio.append("‚úÖ T√≠tulo")
        relatorio.append("‚úÖ Descri√ß√£o")
        relatorio.append("‚úÖ Tipo/Categoria")
        relatorio.append("‚úÖ Data de entrega")
        relatorio.append("‚úÖ Links")
        relatorio.append("‚úÖ Texto completo")
        
        # Salva relat√≥rio
        with open(filename, 'w', encoding='utf-8') as f:
            f.write('\n'.join(relatorio))
        
        logger.info(f"‚úÖ Relat√≥rio salvo em: {filename}")
        
        # Mostra resumo no console
        print("\n" + "="*60)
        print("üìä EXTRA√á√ÉO CONCLU√çDA!")
        print("="*60)
        print(f"üéØ Total de cards extra√≠dos: {total_cards}")
        print(f"üìö Semanas processadas: {len(semanas_processadas)}")
        print(f"üìÅ Dados salvos em: dados_extraidos/")
        print("="*60)
        
        return filename
        
    except Exception as e:
        logger.error(f"‚ùå Erro ao gerar relat√≥rio: {str(e)}")
        return None

async def main():
    """
    Fun√ß√£o principal - Extra√ß√£o completa
    """
    logger.info("üöÄ Iniciando EXTRA√á√ÉO COMPLETA do AdaLove...")
    logger.info(f"üë§ Usu√°rio: {LOGIN}")
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    start_time = time.time()
    todos_os_cards = []

    async with async_playwright() as p:
        try:
            logger.info("üåê Iniciando navegador...")
            browser = await p.chromium.launch(channel="chrome", headless=False)
            context = await browser.new_context()
            page = await context.new_page()
            
            # 1. Login
            logger.info("üîê Fazendo login...")
            await page.goto("https://adalove.inteli.edu.br/")
            await page.wait_for_timeout(3000)
            
            login_sucesso = await fazer_login_inteligente(page)
            
            if not login_sucesso:
                logger.error("‚ùå Falha no login autom√°tico")
                print("\nü§ö Por favor, fa√ßa login manualmente na p√°gina")
                input("‚è∏Ô∏è Pressione Enter ap√≥s fazer login: ")
                logger.info("‚úÖ Login manual confirmado")
            
            # 2. Navega√ß√£o
            logger.info("üè† Navegando para academic-life...")
            await navegar_para_academic_life(page)
            
            # 3. Fecha popup
            await fechar_popup_faltas(page)
            
            # 4. Sele√ß√£o de turma (manual)
            logger.info("üéØ Selecionando turma...")
            await selecionar_turma_manual(page)
            
            # 5. Fecha popup novamente
            await fechar_popup_faltas(page)
            
            # 6. Descobre semanas dispon√≠veis
            logger.info("üîç Descobrindo semanas dispon√≠veis...")
            semanas = await descobrir_semanas_disponiveis(page)
            
            if not semanas:
                logger.error("‚ùå Nenhuma semana encontrada")
                return
            
            logger.info(f"üìö {len(semanas)} semanas para processar")
            
            # 7. Extra√ß√£o de cada semana
            logger.info("üìã Iniciando extra√ß√£o por semana...")
            
            for i, semana in enumerate(semanas, 1):
                logger.info(f"üîÑ Processando {semana} ({i}/{len(semanas)})")
                
                # Volta para academic-life antes de cada semana
                await page.goto("https://adalove.inteli.edu.br/academic-life")
                await page.wait_for_timeout(3000)
                await fechar_popup_faltas(page)
                
                # Extrai cards da semana
                cards_semana = await extrair_cards_semana(page, semana)
                
                if cards_semana:
                    todos_os_cards.extend(cards_semana)
                    logger.info(f"   ‚úÖ {len(cards_semana)} cards extra√≠dos de {semana}")
                else:
                    logger.warning(f"   ‚ö†Ô∏è Nenhum card extra√≠do de {semana}")
                
                # Pequena pausa entre semanas
                await page.wait_for_timeout(2000)
            
            # 8. Salva resultados
            logger.info("üíæ Salvando resultados...")
            
            if todos_os_cards:
                # Salva CSV
                arquivo_csv = await salvar_dados_csv(todos_os_cards, timestamp)
                
                # Salva JSON backup
                arquivo_json = await salvar_dados_json(todos_os_cards, timestamp)
                
                # Gera relat√≥rio
                arquivo_relatorio = await gerar_relatorio_extracao(todos_os_cards, timestamp)
                
                logger.info("üéâ EXTRA√á√ÉO COMPLETA FINALIZADA!")
                
            else:
                logger.error("‚ùå Nenhum card foi extra√≠do")
                
        except Exception as e:
            logger.error(f"‚ùå Erro geral: {str(e)}")
            
        finally:
            logger.info("üîö Finalizando navegador...")
            await context.close()
            await browser.close()

    end_time = time.time()
    duration = end_time - start_time
    logger.info(f"‚è±Ô∏è Extra√ß√£o conclu√≠da em {duration:.1f}s")

if __name__ == "__main__":
    asyncio.run(main())
